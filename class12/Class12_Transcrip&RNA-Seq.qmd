---
title: "Class 12: Transcriptomics & RNA-Seq"
author: "Kira"
format: gfm
---

In this session we will read and explore the gene expression data from this experiment using base R functions and then perform a detailed analysis with the DESeq2 package from Bioconductor.

## 2. Import countData and colData

To begin our RNA-Seq analysis, we first need to import our data:

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
head(counts)
```

```{r}
(metadata)
```

>Q1. How many genes are in this dataset?

```{r}
nrow(counts)
```

There are 38694 genes in this dataset.

>Q2. How many ‘control’ cell lines do we have?

```{r}
table(metadata$dex)
```

There are 4 'control' cell lines.

We also want to ensure that the id column of the metadata matches the order of the columns in countData.

We can use the `all()` function to check if all the inputs are TRUE:

```{r}
all(metadata$id == colnames(counts))
```

The column names of the count data matches the id column of the metadata, so we are all set to start our analysis.

## 3. Toy differential gene expression

Let's first extract our counts for the control samples so that we can compare this to the counts for the treated samples (i.e with drug).

```{r}
# Extracting control information into a table
control.inds <- metadata$dex == "control"
control.ids <- metadata$id[control.inds]
control.counts <- counts[, control.ids]
head(control.counts)
```

I want a single summary counts value for each gene in the control experiments. To start, I will take the average:

```{r}
# Finding an average count value for each gene
control.mean <- rowMeans(control.counts)
head(control.mean)
```

>Q3. How would you make the above code in either approach more robust?

It is more robust to find the mean using either the `rowMeans()` function or the `apply()` function so that it can work for any amount of samples (i.e if the number of samples changed).

>Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
# Extracting control information into a table
treated.inds <- metadata$dex == "treated"
treated.ids <- metadata$id[treated.inds]
treated.counts <- counts[, treated.ids]
head(treated.counts)
```

```{r}
# Finding an average count value for each gene
treated.mean <- rowMeans(treated.counts)
head(treated.mean)
```

```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

```{r}
colSums(meancounts)
```

>Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

```{r}
plot(meancounts$control.mean,meancounts$treated.mean, xlab="Control", ylab="Treated")
```

>Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

The `geom_point()` function would be useful for this plot:

```{r}
library(ggplot2)
ggplot(meancounts) + aes(control.mean,treated.mean) + geom_point() + xlab("Control") + ylab("Treated")
```

>Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

We can use the log.scale argument to plot both axes on a log scale using base R plotting:

```{r}
plot(meancounts$control.mean,meancounts$treated.mean, log="yx", xlab="log Control", ylab="log Treated")
```

The most useful and most straightforward to understand is log2 transformation. We will add a "log2 fold-change" to our data frame by creating a new column:

```{r}
meancounts$log2fc <- log2(meancounts$treated.mean / meancounts$control.mean)
```

```{r}
head(meancounts)
```

Hmmm ... we need to get rid of the genes where we have no count data as taking the log2 of these 0 counts does not tell us anything.

```{r}
to.keep <- rowSums(meancounts[,1:2] == 0) == 0
mycounts <- meancounts[to.keep,]
head(mycounts)
```

```{r}
nrow(mycounts)
```

```{r}
# Another method to remove zero values for gene counts

#zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

#to.rm <- unique(zero.vals[,1])
#mycounts <- meancounts[-to.rm,]
#head(mycounts)
```

>Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The arr.ind argument specifies that the array indices should be returned. We would use the `unique()` function to gather the zero values into a vector that we then can exclude from the counts dataset.

```{r}
up.ind <- sum(mycounts$log2fc >= +2)
down.ind <- sum(mycounts$log2fc <= (-2))
```

>Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

```{r}
up.ind
```

There are 314 genes that are up regulated at the greater than 2 fc level.

>Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
down.ind
```

There are 485 genes that are down regulated at the greater than 2 fc level.

>Q10. Do you trust these results? Why or why not?

We can't really trust these results yet because we haven't determined if the difference in mean and fold change values are statistically significant or not.

## 4. DESeq2 analysis

```{r}
#| message: false
library(DESeq2)
```

Like most bioconductor packages, DESeq2 wants its input and output in a very specific format:

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts, 
                              colData = metadata, 
                              design = ~dex)
```

The main DESeq function is called `DESeq()`:

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```

## 6. Data Visualization: Volcano Plot

These summary figures are frequently used to highlight the proportion of genes that are both significantly regulated and display a high fold change (this will keep both our inner biologist and statistician happy).

```{r}
plot( res$log2FoldChange, res$padj)
```

```{r}
plot( res$log2FoldChange, log(res$padj))
```

We want to flip the y-axis so that the values we're interested in (i.e the low p-value or high log(p-value)) are at the top of the axis. We can improve this plot by taking the negative log of the y-axis (padj):

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```

To make this more useful we can add some guidelines and color highlighting genes that have padj <0.05 and the absolute log2FoldChange >2.

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```

```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "green" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "purple"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)

```

These colored transcripts have both a large fold change and a significant difference between conditions.

## 5. Gene Annotation

We will use one of Bioconductor’s main annotation packages to help with mapping between various ID schemes. Here we load the `AnnotationDbi` package and the annotation data package for humans `org.Hs.eg.db`.

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

We can use the `mapIds()` function to add individual columns to our results table.

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),# Our gene names
                    keytype="ENSEMBL",  # The format of our gene names
                    column="SYMBOL")    # The new format we want to add
```

```{r}
head(res)
```

> Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),
                    keytype="ENSEMBL",
                    column="ENTREZID")
```

```{r}
res$genename <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),
                    keytype="ENSEMBL",
                    column="GENENAME")
```

```{r}
res$uniprot <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),
                    keytype="ENSEMBL",
                    column="UNIPROT")
```

```{r}
head(res)
```

## 7. Pathway Analysis

Here we will use the GAGE package (which stands for Generally Applicable Gene set Enrichment), to do KEGG pathway enrichment analysis on our RNA-seq based differential expression results.

```{r}
library(pathview)
library(gage)
library(gageData)

data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```

The main `gage()` function requires a named vector of fold changes, where the names of the values are the Entrez gene IDs.

```{r}
# Linking Entrez ID to log 2 fold change value
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez

head(foldchanges)
```

```{r}
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

Now we can look at the object returned from `gage()`:

```{r}
attributes(keggres)
```

```{r}
# Look at the first three down (less) pathways
head(keggres$less, 3)
```

Let's look at the highlighted pathways and display our differentially expressed genes:

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```

![The Asthma pathway with my highlighted differentially expressed genes in color](hsa05310.pathview.png)

